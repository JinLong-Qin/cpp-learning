#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <unistd.h>
#include "03.threadpool.h"


void taskFunction(void* arg){
    int num = *(int*) arg;
    printf("thread %ld is workding , number= %d. \n", pthread_self(), num);
    sleep(1);
}


int main(){
    /* 线程池原理
        因为，线程的创建和销毁需要时间，所以当遇到线程数量很多的并发情况的时候，就会大大降低效率。 
        线程池用来解决这个问题：

        线程池是一种[多线程处理形式]，处理过程中将[任务添加到队列]，然后在[创建线程后自动启动这些任务]。
        线程池线程都是[后台线程]。每个线程都使用[默认的堆栈大小，以默认的优先级运行，并处于多线程单元中]。
        如果某个线程在托管代码中空闲（如正在等待某个事件）,则线程池将插入另一个辅助线程来使所有处理器保持繁忙。
        如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。
        超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。


        线程池的组成主要分为3个部分，这三部分配合工作就可以得到一个完整的线程池：
            1. 任务队列，存储需要处理的任务，由工作的线程来处理这些任务； 任务都是函数，所以任务队列中存储的是函数的地址
                1.1.通过线程池提供的API函数，将一个待处理的任务添加到任务队列，或者从任务队列中删除
                1.2.已处理的任务会被从任务队列中删除
                1.3.线程池的使用者，也就是调用线程池函数往任务队列中添加任务的线程就是生产者线程

            2. 工作的线程（任务队列任务的消费者） ，N个
                2.1.线程池中维护了一定数量的工作线程, 他们的作用是是不停的读任务队列, 从里边取出任务并处理
                2.2.工作的线程相当于是任务队列的消费者角色，
                2.3.如果任务队列为空, 工作的线程将会被阻塞 (使用条件变量/信号量阻塞)
                2.4.如果阻塞之后有了新的任务, 由生产者将阻塞解除, 工作线程开始工作

            3. 管理者线程（不处理任务队列中的任务），1个
                它的任务是周期性的对任务队列中的任务数量以及处于忙状态的工作线程个数进行检测
                    当任务过多的时候, 可以适当的创建一些新的工作线程
                    当任务过少的时候, 可以适当的销毁一些工作的线程



        线程池主要是用来维护一个任务队列和若干个消费者线程；
        谁使用任务队列，谁就是生产者；
        生产者通过线程池提供的api将任务放置在任务队列中
        消费者线程通过从任务队列中取任务，当任务队列是空的，就阻塞消费者线程，通知生产者将任务继续放置到任务队列中
    
    */


    // 编译的时候这样： gcc 03.threadpool.c 03.xianchengchi.c -lpthread -o 03.xianchengchi
    // 要把自己写的头文件也一起编译进去


    // 创建线程池
    ThreadPool* pool = threadPool_create(3, 10, 100);

    // 增加任务
    for (int i = 0; i < 100; ++i)
    {
        int* num = (int*) malloc(sizeof(int));
        *num = i +100;
        threadPoolAdd(pool, taskFunction, num);
    }
    sleep(30); // 拖延30s，保证子线程内的任务处理完毕
    threadPoolDestory(pool);


    return 0;
}