#include <stdlib.h>
#include <pthread.h>
#include <stdio.h>

struct Test
{
    int num;
    int age;
};
// struct Test t; // 使用全局变量


void* callback(void * args);

int main(){
    /** 进程（Process）
     * 进程是[程序的一次执行过程]，它是[系统进行资源分配和调度的基本单位]。
     * [一个程序可以有多个进程实例]在运行。
     * [每个进程都有自己的独立内存空间]，并且拥有完整的系统调用权限。
     * [进程之间相互隔离]，一个进程中的错误不会影响到其他进程。
     * 
     *  线程（Thread）
     * 线程是[进程内的一个执行单元]，它是[CPU调度和分派的基本单位]。
     * [一个进程中可以有多个线程]，这些线程[共享进程的资源]，如内存空间和其他系统资源。
     * [由于线程间共享资源，因此线程间的通信更加容易，但是也更容易引发同步问题。]
     * 
     * 进程和线程之间的
     *  区别：
     *      进程之间是隔离的，而线程共享同一进程的地址空间。
     *      进程切换开销大于线程。
     *      进程间的通信相对复杂，而线程间通信相对简单。
     *  联系
     *      线程是进程的一部分，没有进程就没有线程。
     *      多个线程可以并行执行，提高程序的并发性。
     *      进程和线程都是操作系统调度和管理的基本单位。
     * 
     * 
     */

    /*
        线程概述：
            linux中，[线程是轻量级的进程（LWP：light weight process），在Linux环境下线程的本质仍是进程]。
            在计算机上运行的[程序是一组指令及指令参数的组合，指令按照既定的逻辑控制计算机运行]。
            [操作系统会以进程为单位，分配系统资源]，可以这样理解，
                [进程是资源分配的最小单位]，[线程是操作系统调度执行的最小单位]。
        概念上进程和线程的区别，
            1.进程有自己独立的地址空间, 多个线程共用同一个地址空间
                线程更加节省系统资源, 效率不仅可以保持的, 而且能够更高
                在一个地址空间中多个线程独享: 每个线程都有属于自己的栈区, 寄存器(内核中管理的)
                在一个地址空间中多个线程共享: 代码段(.text段), 堆区(new, malloc出来的资源), 全局数据区(全局变量，静态变量存储的位置，即heap(堆),.bss段,.data段), 打开的文件(文件描述符表)都是线程共享的
            2.线程是程序的最小执行单位, 进程是操作系统中最小的资源分配单位
                每个进程对应一个虚拟地址空间，一个进程只能抢一个CPU时间片
                一个地址空间中可以划分出多个线程, 在有效的资源基础上, 能够抢更多的CPU时间片（不是固定的一二三四这样获取cpu时间片，而是无序的状态）
            3. CPU的调度和切换: 线程的上下文切换比进程要快的多
                上下文切换：进程/线程分时复用CPU时间片，在切换之前会将上一个任务的状态进行保存到寄存器中, 下次抢到cpu时间片的时候，就切换回这个任务的时候, 加载这个状态继续向后运行，[任务从保存到再次加载这个过程就是一次上下文切换。]
            4. 线程更加廉价, 启动速度更快, 退出也快, 对系统资源的冲击小。
                
        如果只是完成一个任务，而不是启动另一个应用程序，就应该选择线程
        注意：
            [在处理多任务程序的时候使用多线程比使用多进程要更有优势，但是线程并不是越多越好]，如何控制线程的个数呢？
                1.文件IO操作：文件IO对CPU是使用率不高, 因此可以分时复用CPU时间片, 线程的个数 = 2 * CPU核心数 (效率最高)
                2.处理复杂的算法(主要是CPU进行运算, 压力大)，线程的个数 = CPU的核心数 (效率最高)



    */

    // 主线程默认是存在的，启动一个程序会得到进程，进程调用创建线程的程序，会创建一个线程，这时候，原本的进程就会退化为一个主线程
    /* 同进程一样，每个线程都有一个唯一的线程id，类型为 pthread_t ,底层是一个无符号长整型

    pthread_t pthread_self(void); // 返回当前线程的id


    // 1.创建子线程
    // [在一个进程中调用线程创建函数，就可得到一个子线程]，和进程不同，需要[给每一个创建出的线程指定一个处理函数]，否则这个线程无法工作。
int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
                   void *(*start_routine) (void *), void *arg);
    // Compile and link with -pthread, 线程库的名字叫pthread, 全名: libpthread.so libptread.a
    void *是一个泛型，表示可以将任意类型的数据传递进去，可以创建一个结构体，将参数使用结构体传递，可以包含多种类型的参数

    参数:
        thread: [传出参数]，是无符号长整形数，线程创建成功, 会将线程ID写入到这个指针指向的内存中
        attr: 线程的属性, 一般情况下使用默认属性即可, 写NULL
        start_routine: 函数指针，创建出的[子线程的处理动作]，也就是该函数在子线程中执行。 回调函数
        arg: 作为实参传递到 start_routine 指针指向的函数内部.传递参数到回调函数中
    返回值：线程创建成功返回0，创建失败返回对应的错误号


    2.线程退出
    在编写多线程程序的时候，如果想要让线程退出，但是[不会导致虚拟地址空间的释放（针对于主线程）]，
        我们就可以调用线程库中的线程退出函数，只要调用该函数当前线程就马上退出了，并且不会影响到其他线程的正常运行，不管是在子线程或者主线程中都可以使用。

    void pthread_exit(void *retval);
    参数: 线程退出的时候携带的数据，当前子线程的主线程会得到该数据。如果不需要使用，指定为NULL
    // 通过 pthread_exit 传出的数据，可以在主线程回收的时候，得到，即 会保存在 pthread_join 的第二个参数中

    3.线程回收
        线程和进程一样，子线程退出的时候其内核资源主要由主线程回收，线程库中提供的线程回收函叫做pthread_join()，
        这个函数是一个[阻塞函数]，如果还有子线程在运行，调用该函数就会阻塞，子线程退出函数解除阻塞进行资源的回收，
        [函数被调用一次，只能回收一个子线程，如果有多个子线程则需要循环进行回收。]

        !主线程回收子线程资源，不是所有资源都要主线程来回收，回收的是[内核区]的资源

    // 这是一个阻塞函数, 子线程在运行这个函数就阻塞
    // 子线程退出, 函数解除阻塞, 回收对应的子线程资源, 类似于回收进程使用的函数 wait()
    int pthread_join(pthread_t thread, void **retval);
    参数:
        thread: 要被回收的子线程的线程ID
        retval: 二级指针, 指向一级指针的地址, 是一个传出参数, 这个地址中存储了pthread_exit() 传递出的数据，如果不需要这个参数，可以指定为NULL
    返回值：线程回收成功返回0，回收失败返回错误号。


    4.线程分离
        如果线程不分离，主线程先退出，子线程就没人回收了，会变成僵尸线程，
        而线程分离后，即使主线程先退出，子线程自己会回收，彼此互不干涉，主线程不用等着回收子线程
        !主要是由于pthread_join函数会阻塞主线程的运行
    在某些情况下，程序中的主线程有属于自己的业务处理流程，如果让主线程负责子线程的资源回收，
        调用pthread_join()只要子线程不退出主线程就会一直被阻塞，主要线程的任务也就不能被执行了。
    在线程库函数中为我们提供了线程分离函数pthread_detach()，调用这个函数之后指定的子线程就可以和主线程分离，
        当子线程退出的时候，其占用的内核资源就被系统的其他进程接管并回收了。
        线程分离之后在主线程中使用pthread_join()就回收不到子线程资源了。
    // 参数就子线程的线程ID, 主线程就可以和这个子线程分离了
    int pthread_detach(pthread_t thread);
    当子线程被分离之后，即使主线程退出，也不会影响被分离的子线程的执行

    5. 线程取消
    线程取消的意思就是在某些特定情况下在一个线程中杀死另一个线程。使用这个函数杀死一个线程需要分两步：

        1.在线程A中调用线程取消函数pthread_cancel，指定杀死线程B，这时候线程B是死不了的
        2.!在线程B中进程[直接或间接的执行了一次系统调用]（即调用系统函数。从用户区切换到内核区），否则线程B可以一直运行。

    // 参数是子线程的线程ID
    int pthread_cancel(pthread_t thread);
    
    返回值：函数调用成功返回0，调用失败返回非0错误号。

    6.线程id比较
    在Linux中线程ID本质就是一个无符号长整形，因此可以直接使用比较操作符比较两个线程的ID，
        但是线程库是可以跨平台使用的，在某些平台上 pthread_t可能不是一个单纯的整形，这中情况下比较两个线程的ID必须要使用比较函数，

    int pthread_equal(pthread_t t1, pthread_t t2);
    参数：t1 和 t2 是要比较的线程的线程ID
    返回值：如果两个线程ID相等返回非0值，如果不相等返回0





    */

    //! 编译的时候要增加-lpthread参数，对应到本文件就是  gcc 01.pthread_create.c -lpthread -o 01.pthread_create
    // 创建子线程实例
    struct Test t;
    pthread_t tid; // 创建子线程 id
    // pthread_create(&tid, NULL, callback, NULL); // 四个参数分别为 线程id，线程属性，线程执行函数，传递给执行函数的参数
    pthread_create(&tid, NULL, callback, &t); // 将t作为参数传递进去

    // for (int i = 0; i < 5; ++i)
    // {
    //     printf("主线程： i = %d \n", i);
    // }
    
    printf("主线程：%ld \n", pthread_self());
    // 解决子线程不执行的方法1
    // sleep(3); // 让主线程停止运行，此时主线程放弃cpu资源，然后子线程就可以抢到资源执行，否则，主线程执行完之后，直接释放自己的内存空间，其子线程还没有抢到资源做运行，就被销毁了
    
    
    // 解决子线程不执行的方法2
    // pthread_exit(NULL);  // 退出主线程，但是不释放地址空间，所以子线程还可以接着执行

    /* // pthread_join
    // pthread_join(tid, NULL); // pthread_join会阻塞程序，也会等待子线程执行完毕， 第二个参数设置为NULL表示不接收子线程的返回数据
    void * ptr;
    pthread_join(tid, &ptr);
    struct Test* pt = (struct Test*)ptr; // 将接受的值，转换一下数据类型
    // printf("num: %d, age: %d", pt->num, pt->age); // 这样得到的值是错误的，原因是因为，直接局部变量定义在栈中，程序执行完之后，栈会释放，所以在150行中构建的Test t的值就释放了，所以通过地址取到的值就是错的
    // 那么如何解决这个问题呢，
    //  1. 修改Test t为静态变量或者全局变量，这样t就会保存在堆内，全局就都可以取到值了，这里不建议设置为静态变量，因为如果使用static在callback函数中对t进行修饰，其他的子线程无法访问这个地址，相当于整体的内存空间会变小
    //  2. 将Test t设置在主线程中，然后通过pthread_create的第四个参数，将t作为参数传递进去

    // 此时，当子线程对t进行修改后，就可以直接通过t得到修改后的值了
    printf("num: %d, age: %d \n", t.num, t.age);
    */

    // 线程分离
    pthread_detach(tid);
    // 即便主线程退出了，也不会影响子线程的执行
    pthread_exit(NULL);
    return 0;
}

void* callback(void * args){

    for (int i = 0; i < 5; ++i)
    {
        printf("子线程： i = %d \n", i);
    }
    
    printf("子线程：%ld \n", pthread_self());

    // 使用结构体，模拟子线程结束时带回的数据
    // 结构体可以存储多种类型的数据
    /* struct Test t; // 局部变量在执行结束后，会将栈释放，所以主线程得不到对应的值
    t.age = 20;
    t.num = 30;
    */
    struct Test* t = (struct Test* )args; // 接收参数，将其强转数据类型
    t->age = 20;
    t->num = 30;

    pthread_exit(&t);  // 线程退出，带回的数据是t
    return NULL;
}