#include <iostream>
#include "05.cpp11.ThreadPool.h"
#include <memory>

using namespace std;


void calc(int x, int y){
    int z = x+y;
    cout << "z = " << z << endl;

    // 线程休眠2秒，模拟实际情况中大量任务代码的执行
    this_thread::sleep_for(chrono::seconds(2));
}
/*  线程异步
    线程异步（Asynchronous Threading）是一种编程范式，用于[执行任务或操作而不阻塞主线程或其他线程的执行]。
    这种方法特别适用于需要[同时处理多个操作或在后台执行长时间运行的任务的场景]。
    线程异步的[核心思想是将耗时的操作与主执行流程分离，使得系统能够继续处理其他任务，而无需等待耗时操作完成。]

    - 异步执行：与同步操作不同，异步操作不要求调用者在任务完成之前等待结果。异步操作通常会在后台线程中执行，主线程或其他线程可以继续执行其他任务。
    - 线程：在多线程编程中，异步操作通常通过创建新的线程来实现。新线程会执行异步任务，而主线程则继续进行其他操作。

    当线程池中的任务函数有返回值，我们就可以通过线程异步的方式，将子线程也就是工作的线程的返回值传递给主线程。
        其核心操作就是修改添加任务的函数 addTask 。见05.cpp11.ThreadPool.h文件




    

*/
int calcl(int x, int y){ // 模拟有返回值的任务函数
    int z = x+y;

    // 线程休眠2秒，模拟实际情况中大量任务代码的执行
    this_thread::sleep_for(chrono::seconds(5));

    return z;
}


int main(){
    // 基于c++11实现的异步线程池
    // g++ 05.cpp11.ThreadPool.cpp 05.cpp11.yibuxianchengchi.cpp -o 05.cpp11.yibuxianchengchi
    /*
        **线程池的基本思想是预先创建一定数量的线程，并将它们放入一个池中。线程池负责管理线程的生命周期，并将任务分配给空闲线程执行。这样可以避免每次任务执行时都创建和销毁线程的开销。

        线程池的组成：
            1.线程池管理器：负责创建、销毁线程，维护线程池状态（如空闲线程、忙碌线程）。 有且只有一个
            2.任务队列：用于存储待执行的任务。任务通常以函数对象（如 std::function）的形式存储。 
            3.工作线程：线程池中的实际线程，它们从任务队列中取出任务并执行。 有多个
            4.同步机制：用于保护任务队列和线程池状态的线程安全操作，通常使用互斥锁和条件变量。

        设计线程池需要考虑的重要原则：
            1.线程池大小管理：
                1.1.固定大小：线程池中的线程数量固定不变。适用于负载比较稳定的场景。
                1.2.动态调整：根据任务负载动态调整线程池大小。适用于负载变化较大的场景。
            2.任务队列管理：
                2.1.FIFO 队列：最常用的任务队列实现方式，按照任务提交的顺序执行任务。 queue
                2.2.优先级队列：根据任务的优先级执行任务，适用于需要按优先级处理任务的场景。 
            3.线程安全：
                3.1.互斥锁：用于保护共享资源（如任务队列）的访问。 实现线程同步
                    互斥锁的目的就是为了在新数据没有从寄存器同步到内存之前，不让其他线程访问这块内存资源
                3.2.条件变量：用于线程之间的通信，如通知空闲线程有新的任务到来。 阻塞线程 
                3.3.原子变量：对原子变量的操作都是原子操作，它是线程安全的。
                    原子变量是一个类，通过原子变量就可以在原子变量内部完成线程的同步。所有的数据变化都是原子操作。原子操作是指：变量在变化期间，线程是不会变化的。
            4.任务执行与错误处理：
                任务执行过程中的异常需要适当处理，以避免线程池中的线程因未捕获异常而终止。

    */

    /* 没写异步的时候
    ThreadPool pool; // 不给参数，默认最小线程数2 最大线程数为cpu的核心数
    
    
    // 循环给任务列表中加任务
    for (int i = 0; i < 10; ++i)
    {
        // 在ThreadPool类中定义的任务列表中存储的是无参无返回值的可调用函数，这里的calc是有参数的，
        // 使用bind来对calc进行处理
        // bind参数依次是，要处理的函数，[按照形参顺序给定的实参]；返回值是一个无参的可调用函数，此时就可以加入到ThreadPool的任务列表了
        auto func = bind(calc, i, i*2);
        pool.addTask(func); 
    }
    */
    // 异步线程池测试
    ThreadPool pool;
    vector<future<int>> results;

    // 添加任务列表
    for (int i = 0; i < 10; ++i)
    {
        // 给定函数calcl和其参数，并将其返回值保存在results
        results.emplace_back(pool.addTask(calcl, i, i*2));
    }
    
    // future类型不允许拷贝，所以使用引用把值取出来
    for(auto& it: results){
        cout << "线程执行的结果是 " << it.get() << endl;
        // 注意 get()方法是阻塞函数，即，如果future对象中还没有数据（线程中函数还没执行完，返回值还没有保存到future对象中)，函数就会阻塞。直到future函数中被写入数据了，才会继续执行下去，
        // 正是由于这个阻塞，才保证了取到的值是正确的
    }

    

    // getchar(); // 阻塞主线程，防止看不到打印结果
    cin.get();
    // system("pause"); // 这个是windows的
    return 0;
}